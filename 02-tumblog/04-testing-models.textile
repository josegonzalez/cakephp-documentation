h1. Model Testing

I won't go over 100% of the model testing here - the full application + full unit test coverage will come at the end of the series - but it will give you some ideas as to how to test models.

CakePHP provides Unit Test functionality. A Unit Test is a simple piece of code that tests, given a certain input, that an output or range of outputs will occur. Think of unit tests as internal documentation for your application's api. Given a working unit test, your application should always pass the unit test, or some notion you, or another developer, had in the past is no longer true. In cases where a unit test is broken, you either adjust your code or adjust the unit test, depending upon the reason why it broke.

Some good reasons to adjust your code:

* You made a change to production code that interacts with a complex model and has exacting specifications
* Merging in broken code
* Stability for outside developers (crucial for external APIs)

Some good reasons for adjusting your tests

* The test is invalid, ie. is just plain wrong
* The data set the test iterates over is no longer valid
* New use cases mean some tests are incorrect

There can be others as well. Regardless, it is always good practice to have unit tests for at least your most complicated functions and portions of code. For more on unit tests, visit the "Wikipedia article on Unit Tests":http://en.wikipedia.org/wiki/Unit_testing.

h2. CakePHP "Quirks"

CakePHP uses SimpleTest. Your complaining will not change it overnight to PHPUnit. For the record, PHPUnit integration is scheduled for CakePHP 2.0.

Installation of SimpleTest can be done by downloading the latest stable version - 1.0.1 as of this writing - and extracting the contents to @app/vendors/simpletest@. It is also possible to install it into your global @vendors@ directory, or even a Plugin's @vendors@ directory.

Testing an installation is simple. Simply set @debug@ to a value greater than 0 in your @app/config/core.php@ and go to @example.com/test.php@ - where @example.com@ is the domain-name/path pointing to your application. A nice test page should appear if everything went well.

Please also install the "XDebug":http://www.xdebug.org/ PHP extension. It allows you to introspect on code coverage, meaning your unit testing can help you find unused code paths or code paths that have yet to be tested. Installing this can be as simple as @brew install xdebug@ and enabling the xdebug.so in your php.ini, or as complicated as compiling a binary .so file for your Operating System and yelling at PHP. Please consult the xdebug website or others familiar with your development environment for more help on this.

Unit test cases should go in a directory structure similar to how the app structure works for code coverage to work. A model test for our *Post* model would go in @app/tests/cases/models/post.test.php@. If a test uses data from a model, you typically have a fixture to mock database records. A fixture for our *Post* model would go in @app/tests/fixtures/post_fixture.php@.

Fixtures can be auto-generated by the @cake fixture@ command. Please consult the documentation on this command for more details.

h2. Testing

The following is the simplest of all CakeTestCases:

<pre><code><?php
App::import('Model','Post');
class PostTestCase extends CakeTestCase {
    var $fixtures = array('app.post');
}
?></code></pre>

The above is the base test case for our @Post@ model. We need to @App::import()@ the Model we are testing so that we can create an instance of it within our tests. If you need other classes in your test cases that aren't already loaded within the model, please also @App::import()@ those as well. Generally, a unit test tests a single class, so that will likely not apply to your case.

We also need to define all the fixtures in use by this testcase. If your model has related models, you need to include the fixtures of the related models. Notice the notation @app.post@. This implies that one wishes to load the @post@ fixture from the @app@. If we used @blog.post@, we would try to load the @post@ fixture from the @blog@ plugin.

Our test case doesn't do much - it actually doesn't do anything - so lets write our first test. When we create a new @Post@ model, we use the constructor to create the post types. Lets test that we have exactly 4 post types, and what those post types are:

<pre><code><?php
App::import('Model','Post');
class PostTestCase extends CakeTestCase {
    var $fixtures = array('app.post');

    function testPostTypes() {
        $Post = ClassRegistry::init('Post');

        $result = count($Post->postTypes);
        $this->assertEqual($result, 4);

        $result = $Post->postTypes[0];
        $this->assertEqual($result, 'Images');

        $result = $Post->postTypes[1];
        $this->assertEqual($result, 'Links');

        $result = $Post->postTypes[2];
        $this->assertEqual($result, 'Text');

        $result = $Post->postTypes[3];
        $this->assertEqual($result, 'Youtube');
    }

}
?></code></pre>

Running the test should result in the following: @1/1 test cases complete. 5 passes and 0 fails.@. It's a pretty simple unit test. Because of the way we set up the model, it would be possible to also test that the output of each post type is localized... But for our use case, we will not need to test this yet.